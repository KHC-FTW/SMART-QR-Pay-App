package com.khchan744.smart_qr_pay.activity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.EdgeToEdge;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.camera.core.ExperimentalGetImage;
import androidx.camera.view.PreviewView;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;

import com.google.mlkit.vision.barcode.common.Barcode;
import com.khchan744.smart_qr_pay.R;
import com.khchan744.smart_qr_pay.bgservice.QrScanner;

import java.nio.charset.StandardCharsets;
import java.util.Locale;

/**
 * Scans QR codes using the device camera.
 *
 * Acceptance rule: Only accepts SmartQrPay QR payloads generated by {@link GenQRActivity}:
 *   SQRP|v1|len=<n>|ts=<millis>\n<message bytes>
 * padded with 0x00 to 770 bytes.
 */
@ExperimentalGetImage
public class ScanQRActivity extends AppCompatActivity implements QrScanner.QrScannerCallback {

    private static final String HEADER_PREFIX = "SQRP|v1|len=";

    private View cameraContainer;
    private View resultsContainer;
    private PreviewView previewView;

    private TextView tvScannedMessageValue;
    private TextView tvTimeTakenValue;

    private QrScanner qrScanner;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        EdgeToEdge.enable(this);
        setContentView(R.layout.activity_scan_qr);

        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -> {
            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);
            return insets;
        });

        cameraContainer = findViewById(R.id.cameraContainer);
        resultsContainer = findViewById(R.id.scannedResultsContainer);
        previewView = findViewById(R.id.previewView);

        tvScannedMessageValue = findViewById(R.id.tvScannedMessageResults);
        tvTimeTakenValue = findViewById(R.id.tvTimeTakenValue);

        Button btnScanAgain = findViewById(R.id.btnScanAgain);
        Button btnBackToMenu = findViewById(R.id.btnBackToMenu);

        btnScanAgain.setOnClickListener(v -> startScanningFlow());
        btnBackToMenu.setOnClickListener(v -> {
            qrScanner.stop();
            startActivity(new Intent(this, DeveloperModeActivity.class));
            finish();
        });
        findViewById(R.id.btnBack).setOnClickListener(v -> finish());

        qrScanner = new QrScanner(this, previewView, this);

        // Start immediately
        startScanningFlow();
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (cameraContainer.getVisibility() == View.VISIBLE) {
            qrScanner.start();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();
        qrScanner.stop();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        qrScanner.release();
    }

    private void startScanningFlow() {
        // UI updates
        resultsContainer.setVisibility(View.GONE);
        cameraContainer.setVisibility(View.VISIBLE);
        tvScannedMessageValue.setText("");
        tvTimeTakenValue.setText("");

        // Allow new scan
//        qrScanner.resumeScanning();
        qrScanner.start();
    }

    @Override
    public void onQrScanned(@NonNull Barcode barcode) {
        ParsedPayload parsed = tryParsePayloadFromBarcode(barcode);
        if (parsed == null) {
            // Not our QR code, continue scanning
            qrScanner.resumeScanning();
            return;
        }

        long scanDoneMs = System.currentTimeMillis();
        qrScanner.stop();
        showResult(parsed.message, parsed.payloadTimestampMs, scanDoneMs);
    }

    @Override
    public void onCameraSetupFailed(@NonNull String message) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show();
    }

    private void showResult(@NonNull String message, long payloadTimestampMs, long scanDoneMs) {
        cameraContainer.setVisibility(View.GONE);
        resultsContainer.setVisibility(View.VISIBLE);

        tvScannedMessageValue.setText(message);

        double seconds = Math.max(0, scanDoneMs - payloadTimestampMs) / 1000.0;
        tvTimeTakenValue.setText(String.format(Locale.US, "%.3f s", seconds));
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        qrScanner.onRequestPermissionsResult(requestCode, grantResults);
    }

    private static class ParsedPayload {
        final String message;
        final long payloadTimestampMs;

        ParsedPayload(String message, long payloadTimestampMs) {
            this.message = message;
            this.payloadTimestampMs = payloadTimestampMs;
        }
    }

    private static ParsedPayload tryParsePayloadFromBarcode(@NonNull Barcode barcode) {
        // MLKit provides raw bytes for QR if present.
        byte[] raw = barcode.getRawBytes();
        if (raw != null && raw.length > 0) {
            // Our payload contains an ASCII header and then UTF-8 message bytes, and is padded with 0x00.
            // Decode raw bytes losslessly into ISO-8859-1 text, then parse.
            String asText = new String(raw, StandardCharsets.ISO_8859_1);
            ParsedPayload parsed = tryParsePayload(asText);
            if (parsed != null) return parsed;
        }

        // Fallback to display value.
        String text = barcode.getRawValue();
        if (text == null) return null;
        return tryParsePayload(text);
    }

    /**
     * Validates and parses the GenQRActivity v1 payload.
     *
     * Expected textual prefix: SQRP|v1|len=<n>|ts=<millis>\n
     * Message bytes are UTF-8 and len=<n> refers to UTF-8 byte length.
     */
    private static ParsedPayload tryParsePayload(@NonNull String decodedText) {
        // Trim trailing NULs if present.
        int end = decodedText.length();
        while (end > 0 && decodedText.charAt(end - 1) == '\u0000') {
            end--;
        }
        String trimmed = decodedText.substring(0, end);

        if (!trimmed.startsWith(HEADER_PREFIX)) return null;

        int newlineIdx = trimmed.indexOf('\n');
        if (newlineIdx <= 0) return null;

        String header = trimmed.substring(0, newlineIdx);
        String body = trimmed.substring(newlineIdx + 1);

        int lenStart = header.indexOf("len=");
        int tsStart = header.indexOf("|ts=");
        if (lenStart < 0 || tsStart < 0 || tsStart <= lenStart) return null;

        String lenStr = header.substring(lenStart + 4, tsStart);
        String tsStr = header.substring(tsStart + 4);

        int msgLen;
        long ts;
        try {
            msgLen = Integer.parseInt(lenStr);
            ts = Long.parseLong(tsStr);
        } catch (NumberFormatException e) {
            return null;
        }

        if (msgLen < 0 || msgLen > 5000) return null;

        byte[] bodyBytes = body.getBytes(StandardCharsets.UTF_8);
        if (bodyBytes.length < msgLen) return null;

        byte[] msgBytes = new byte[msgLen];
        System.arraycopy(bodyBytes, 0, msgBytes, 0, msgLen);

        String message = new String(msgBytes, StandardCharsets.UTF_8);
        return new ParsedPayload(message, ts);
    }
}
